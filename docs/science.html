<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Raphael Feser -</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&amp;display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/ngl@2.3.1/dist/ngl.js"></script>


<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="Raphael Feser -">
<meta property="og:site-name" content="Raphael Feser">
<meta name="twitter:title" content="Raphael Feser -">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Raphael Feser</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-research" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Research</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-research">    
        <li>
    <a class="dropdown-item" href="./science.html" rel="" target="">
 <span class="dropdown-text">CCR5 (viewer)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./survival.html" rel="" target="">
 <span class="dropdown-text">SLNB (viewer)</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="./about.html" rel="" target="">
 <span class="menu-text">Activities</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">




<meta name="description" content="Interactive walkthrough of CCR5 receptor activation. Molecular simulations and structural data for GPCR drug discovery research.">

<div class="desktop-banner">
  ⓘ&nbsp; Best viewed on a desktop - this page contains interactive 3D viewer and animations.
</div>

<div class="science-page">

  <div class="science-page-header">
    <h1>CCR5: structure and dynamics of activation</h1>
    <p>Two ligands bind the same receptor. They differ by only a few amino acids, yet stabilise distinct activation states.</p>
    <p class="research-context-note">Ongoing PhD research · Public reference structures (PDB: 5UIW, 7O7F)</p>
  </div>

  <!-- NGL Viewer -->
  <div class="science-viewer-wrap">
    <div id="science-viewer"></div>
    <div class="viewer-loading" id="viewer-loading"><div class="viewer-spinner"></div>Loading structure…</div>
    <div class="viewer-toggle" id="viewer-toggle" style="display:none">
      <button class="toggle-btn active" id="toggle-5p7" onclick="switchComplex('5p7')">Blocking molecule</button>
      <button class="toggle-btn" id="toggle-wt" onclick="switchComplex('wt')">Activating molecule</button>
    </div>
    <div class="model-note" id="model-note" style="display:none"></div>
    <div class="traj-label" id="traj-label" style="display:none">
      Helix 6 (orange) moves outward as the receptor activates
    </div>
    <!-- Trajectory play/pause - shown only on step 5 -->
    <div class="traj-controls" id="traj-controls" style="display:none">
      <button class="viewer-ctrl-btn" id="traj-playpause" onclick="togglePlayPause()">Pause</button>
    </div>
    <!-- Colorblind palette toggle - always visible when viewer is active -->
    <button class="viewer-ctrl-btn cvd-btn" id="cvd-btn" onclick="toggleCVD()" title="Switch to colorblind-friendly palette" aria-label="Toggle colorblind palette">● Color</button>
  </div>

  <!-- Progress dots -->
  <div class="step-progress" role="tablist" aria-label="Chapter navigation">
    <button class="step-dot active" onclick="goToStep(0)" role="tab" aria-label="Chapter 1: The target" aria-selected="true"></button>
    <button class="step-dot" onclick="goToStep(1)" role="tab" aria-label="Chapter 2: The chemokines" aria-selected="false"></button>
    <button class="step-dot" onclick="goToStep(2)" role="tab" aria-label="Chapter 3: The structure" aria-selected="false"></button>
    <button class="step-dot" onclick="goToStep(3)" role="tab" aria-label="Chapter 4: Watching it move" aria-selected="false"></button>
  </div>

  <!-- ── Chapter 1 ─────────────────────────────────────────────────────── -->
  <div class="science-chapter active" id="chapter-0">
    <p class="chapter-label">01 The target</p>
    <h2 class="chapter-title anchored">CCR5: a receptor on the surface of immune cells</h2>
    <div class="chapter-body">
      <p>
        Proteins carry out most functions in cells. Some proteins, called receptors, allow cells to sense
        signals from their environment and translate them into intracellular responses. CCR5 is a
        transmembrane receptor that guides immune cells by detecting chemical signals during immune responses.
        It belongs to the GPCR family, the most widely targeted class of drug receptors. Drugs often act by
        binding to receptors and changing their activity. Because CCR5 regulates immune-cell trafficking,
        it is a promising target for modifying disease progression in inflammatory and cancer diseases.
      </p>
      <p>
        In the default camera view, the bottom corresponds to the intracellular side and the top to the
        extracellular side. The ligand binds at the extracellular face.
      </p>
    </div>
  </div>

  <!-- ── Chapter 2 ─────────────────────────────────────────────────────── -->
  <div class="science-chapter" id="chapter-1">
    <p class="chapter-label">02 The chemokines</p>
    <h2 class="chapter-title anchored">A few amino-acid changes. Opposite effects.</h2>
    <div class="chapter-body">
      <p>
        CCR5 responds to chemokines, small signalling proteins. One example is CCL5, a chemokine
        composed of about 70 amino acids. Researchers created modified versions of CCL5 by changing
        only a few amino acids at its tip, the region that inserts into the receptor. Despite these
        minimal changes, their effects are opposite: one blocks CCR5, while the other activates it
        more strongly than the natural chemokine.
      </p>

      <div class="nterm-table-wrap">
        <p class="table-intro">Tip of the chemokines, first 10 positions (out of ~70 total):</p>
        <div class="nterm-table-scroll">
          
<table class="nterm-table table" data-quarto-postprocess="true">
<thead>
<tr class="header">
<th class="row-label" data-quarto-table-cell-role="th">Molecule</th>
<th class="same" data-quarto-table-cell-role="th">1</th>
<th class="same" data-quarto-table-cell-role="th">2</th>
<th class="same" data-quarto-table-cell-role="th">3</th>
<th class="same" data-quarto-table-cell-role="th">4</th>
<th class="diff" data-quarto-table-cell-role="th">5</th>
<th class="diff" data-quarto-table-cell-role="th">6</th>
<th class="diff" data-quarto-table-cell-role="th">7</th>
<th class="diff" data-quarto-table-cell-role="th">8</th>
<th class="diff" data-quarto-table-cell-role="th">9</th>
<th class="diff" data-quarto-table-cell-role="th">10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td class="row-label antagonist-label">Blocker</td>
<td class="same">pGlu</td>
<td class="same">Gly</td>
<td class="same">Pro</td>
<td class="same">Pro</td>
<td class="diff">Leu</td>
<td class="diff">Met</td>
<td class="diff">Ala</td>
<td class="diff">Leu</td>
<td class="diff">Gln</td>
<td class="diff">Ser</td>
</tr>
<tr class="even">
<td class="row-label agonist-label">Activator</td>
<td class="same">pGlu</td>
<td class="same">Gly</td>
<td class="same">Pro</td>
<td class="same">Pro</td>
<td class="diff">Gly</td>
<td class="diff">Asp</td>
<td class="diff">Ile</td>
<td class="diff">Val</td>
<td class="diff">Leu</td>
<td class="diff">Ala</td>
</tr>
</tbody>
</table>


        </div>
        <p class="table-caption">
          <span class="legend-same">■</span> Identical &nbsp;&nbsp;
          <span class="legend-diff">■</span> Variable positions (5–10)
        </p>
      </div>
    </div>
  </div>

  <!-- ── Chapter 3 ─────────────────────────────────────────────────────── -->
  <div class="science-chapter" id="chapter-2">
    <p class="chapter-label">03 The structure</p>
    <h2 class="chapter-title anchored">The same receptor. The same binding site. Very different outcomes.</h2>
    <div class="chapter-body">
      <p>
        Both chemokines bind to the same region of CCR5 and insert their tip into the receptor in a
        similar way. However, the
        receptor responds differently. When bound to the activating chemokine, one intracellular helix
        moves outward, allowing signalling proteins to bind inside the cell. With the blocking chemokine,
        this movement does not occur. This suggests that activation depends not only on where a ligand
        binds, but on how the receptor changes shape.
      </p>
      <p>Use the toggle above to compare the two structures.</p>
    </div>
  </div>

  <!-- ── Chapter 4 ─────────────────────────────────────────────────────── -->
  <div class="science-chapter" id="chapter-3">
    <p class="chapter-label">04 Watching it move</p>
    <h2 class="chapter-title anchored">From structure to dynamics.</h2>
    <div class="chapter-body">
      <p>
        GPCRs are not rigid structures. They fluctuate between many shapes, only some of which can
        signal. Ligands influence this balance by stabilising particular conformations. The outward
        motion of the intracellular helix observed above reflects a shift toward an active state.
      </p>
      <p>
        Molecular dynamics simulations describe how atoms move over time using physics-based
        calculations. The animation shows CCR5 evolving along a simulated trajectory. The highlighted
        helix moves outward as the receptor approaches an active geometry. These simulations help us
        understand not only where a ligand binds, but how it reshapes receptor dynamics and stabilises
        different functional states.
      </p>
    </div>
  </div>

  <!-- Navigation -->
  <div class="science-nav">
    <button class="btn-step-prev" id="btn-prev" disabled="" onclick="stepNav(-1)">← Previous</button>
    <span class="step-counter" id="step-counter">1 / 4</span>
    <button class="btn-amber" id="btn-next" onclick="stepNav(1)">Next →</button>
  </div>

</div><!-- /science-page -->

<!-- ── Enhanced sampling section ─────────────────────────────────────────── -->
<div class="enh-section">
  <p class="enh-section-label">Methods</p>
  <h2 class="anchored">Sampling rare transitions</h2>
  <p>
    The conformational changes described above often occur on timescales that are inaccessible to standard molecular
    dynamics simulations. At physiological temperature, a trajectory may remain trapped within a single conformational
    basin, separated from other states by free-energy barriers. As a result, slow transitions such as GPCR activation
    may not be observed within practical simulation times.
  </p>
  <p>
    Enhanced sampling is illustrated here by an adaptive biasing method called metadynamics. This approach constructs
    a history-dependent bias along a chosen collective variable (CV), a low-dimensional descriptor of the protein’s
    configuration. By progressively filling previously visited regions of the free-energy landscape, the bias promotes
    transitions between states that would otherwise be rarely observed.
  </p>

  <p>
    Because the applied bias is known, free-energy profiles along the selected CV can be reconstructed afterward
    (illustrative). The underlying principle is closely related to importance sampling: instead of sampling directly
    from the distribution of interest, we explore a modified distribution that is easier to sample and later recover
    the unbiased distribution through reweighting. The ΔG slider below sketches how a ligand or mutation shifts
    the balance between conformational states.
  </p>

  <div class="interactive-zone" style="margin:1.25rem 0 1rem;">
    <div class="iz-header">
      <div class="iz-title">Illustrative free energy landscape for receptor activation</div>
      <div class="iz-badge">● interactive</div>
    </div>
    <div class="iz-body">
      <canvas id="enhCanvas" height="310" role="img" aria-label="Interactive free energy landscape showing conformational states of the receptor"></canvas>

      <div style="display:flex;align-items:flex-start;gap:20px;margin-top:14px;flex-wrap:wrap;">
        <!-- Mode toggle -->
        <div>
          <div style="font-family:var(--font-heading);font-size:0.78rem;font-weight:600;color:var(--color-text-muted);margin-bottom:6px;text-transform:uppercase;letter-spacing:0.06em;">Sampling mode</div>
          <div class="enh-mode-row">
            <button class="enh-mode-btn active" id="enhBtnClassical" onclick="setEnhMode('classical')">Standard MD</button>
            <button class="enh-mode-btn" id="enhBtnEnhanced" onclick="setEnhMode('enhanced')">Adaptive bias (e.g., metadynamics)</button>
          </div>
          <div style="font-size:0.74rem;color:var(--color-text-muted);max-width:230px;line-height:1.5;margin-top:6px;" id="modeCaption">
            Standard MD: a single trajectory may stay in its starting state.
          </div>
        </div>
        <!-- Slider -->
        <div style="flex:1;min-width:160px;">
          <label style="display:block;font-family:var(--font-heading);font-size:0.78rem;font-weight:600;color:var(--color-text-muted);text-transform:uppercase;letter-spacing:0.06em;margin-bottom:6px;">
            Ligand / mutation effect &nbsp;<span id="dGLabel" style="color:var(--color-text);font-weight:700;">Symmetric</span>
          </label>
          <input type="range" id="dGSlider" min="-1.5" max="1.5" step="0.05" value="0.0" style="width:100%;margin-top:2px;" aria-label="Ligand or mutation effect on free energy balance">
          <div class="range-labels"><span>Favours active</span><span>Favours inactive</span></div>
          <div style="margin-top:12px;">
            <div class="enh-dg-label">ΔG (active − inactive)</div>
            <div class="enh-dg-num" id="dGNum">0.0</div>
            <div style="font-size:0.74rem;color:var(--color-text-muted);font-family:var(--font-heading);">kcal/mol · illustrative</div>
          </div>
        </div>
      </div>

      <div class="enh-result" id="enhResult">
        The two states are equally stable. Move the slider to tilt the landscape and see how a ligand or mutation shifts the balance.
      </div>
    </div>
  </div>

  <p>
    Temperature replica exchange methods follow a different enhanced sampling strategy. Multiple copies of the system are simulated simultaneously at a series of temperatures. Replicas at higher temperatures sample higher-energy configurations more readily, allowing them to cross free-energy barriers and explore a broader range of conformations. At regular intervals, neighbouring replicas attempt to exchange configurations according to a Metropolis criterion that depends on their potential energies and temperatures.
  </p>
  <p>
    In this way, configurations discovered at high temperature can gradually move down the temperature ladder. Exchanges are accepted probabilistically based on the energies of the exchanging replicas. This allows barriers to be crossed at higher temperatures, while the 300 K replica still samples the same physical behaviour and explores a broader range of configurations than direct simulation would allow.
  </p>

  <div class="interactive-zone" style="margin:1rem 0 0;">
    <div class="iz-header">
      <div class="iz-title">Replica exchange (parallel tempering), illustration</div>
      <div class="iz-badge">● interactive</div>
    </div>
    <div class="iz-body">
      <canvas id="remdCanvas" height="340" role="img" aria-label="Replica exchange molecular dynamics simulation with four temperature replicas"></canvas>

      <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:12px;">
        <button class="iz-btn" id="remdToggleBtn" type="button">Exchanges OFF</button>
        <button class="iz-btn" id="remdResetBtn" type="button">Reset</button>
      </div>

      <div style="font-size:0.74rem;color:var(--color-text-muted);line-height:1.5;margin-top:8px;max-width:640px;">
        Illustrative. The 300 K replica (★) is the simulation with the temperature of interest.
        Temperature replica exchange improves sampling by helping the system overcome energy barriers that would
        be crossed only rarely at 300 K. Higher-temperature replicas explore conformations more easily,
        and periodic exchanges allow these configurations to be tested at lower temperatures. Exchanges are
        accepted probabilistically based on energy and temperature, so the 300 K replica ultimately
        samples configurations consistent with its thermal conditions. Toggle exchanges to observe
        configurations moving across the temperature ladder.
      </div>
    </div>
  </div>

  <p style="margin-top:1.25rem;">
    In my work, I often combine adaptive biasing and replica exchange within one workflow. It makes it quite powerful depending on the
    system and question.
  </p>

</div><!-- /enh-section -->

<script>
// ── Enhanced sampling: energy landscape animation ────────────────────────────
(function () {
  var canvas    = document.getElementById('enhCanvas');
  if (!canvas) return;
  var ctx       = canvas.getContext('2d');
  var dGSlider  = document.getElementById('dGSlider');
  var dGLabel   = document.getElementById('dGLabel');
  var dGNum     = document.getElementById('dGNum');
  var enhResult = document.getElementById('enhResult');
  var modeCap   = document.getElementById('modeCaption');

  // ── Canvas constants (declared first so computeVMIN can use XMIN/XMAX) ──────
  var XMIN = -2.4, XMAX = 2.4;
  var EMIN = -0.3, EMAX = 5.0;
  var NX   = 280;

  // ── Physics parameters ──────────────────────────────────────────────────────
  // Raw potential: V(x, dG) = BARRIER·(x²−1)² + dG·x  [kcal/mol]
  // We normalize so the lower minimum is always at 0 (VMIN shift).
  // This keeps the particle on the landscape curve regardless of dG,
  // and makes the displayed barrier height physically meaningful.
  var BARRIER = 3.0;  // kcal/mol (symmetric barrier when dG = 0)
  var GAMMA   = 2.0;  // overdamped friction coefficient
  var DT      = 0.008;
  var STEPS_PER_FRAME = 10;
  var DG   = 0;
  var VMIN = 0;  // energy offset updated by computeVMIN()

  // Thermal noise level (kcal/mol, illustrative).
  var KT   = 0.30;
  var mode = 'classical';

  // Bias-based illustration: accumulated Gaussians along a 1D coordinate.
  // Well-tempered: deposit height shrinks as bias accumulates →
  // convergence to a non-flat, but accessible, effective landscape.
  var bias      = [];
  var BIAS_H    = 0.12;   // initial Gaussian height (kcal/mol)
  var BIAS_W    = 0.21;   // Gaussian sigma
  var BIAS_FREQ = 20;     // deposit every N steps
  var WT_GAMMA  = 10;     // well-tempered factor; higher → more filling

  var px        = -1.0;   // particle starts in inactive well
  var traceX    = [];
  var stepCount = 0;

  // Visited histogram: bins across x range
  var HIST_BINS = 60;
  var visitHist = new Array(HIST_BINS).fill(0);
  var visitMax  = 1;

  // ── Potential normalization ──────────────────────────────────────────────────
  // Find the global minimum of the raw potential over the displayed x range.
  // Subtracting it keeps the lower minimum at 0 for all dG values.
  function computeVMIN() {
    var minV = Infinity;
    for (var i = 0; i <= 900; i++) {
      var x = XMIN + (XMAX - XMIN) * i / 900;
      var v = BARRIER * (x * x - 1) * (x * x - 1) + DG * x;
      if (v < minV) minV = v;
    }
    VMIN = minV;
  }

  // ── Potential energy functions ──────────────────────────────────────────────
  function Vbase(x) {
    return BARRIER * (x * x - 1) * (x * x - 1) + DG * x - VMIN;
  }
  function Vbias(x) {
    var v = 0;
    for (var i = 0; i < bias.length; i++) {
      var d = x - bias[i].c;
      v += bias[i].h * Math.exp(-d * d / (2 * BIAS_W * BIAS_W));
    }
    return v;
  }
  function Vtotal(x) { return Vbase(x) + Vbias(x); }
  function forceOf(x) {
    var h = 0.004;
    return -(Vtotal(x + h) - Vtotal(x - h)) / (2 * h);
  }

  // Barrier from the lower minimum (= 0 after normalization) to the saddle at x≈0.
  // Changes with dG: when dG ≠ 0 the landscape is asymmetric, both barriers differ.
  function forwardBarrier() {
    // Barrier from inactive well (lower when dG > 0) to saddle
    return Math.max(0, Vbase(0)).toFixed(1);
  }

  // ── Overdamped Langevin step ────────────────────────────────────────────────
  function step() {
    var u1 = Math.random() + 1e-12, u2 = Math.random();
    var xi  = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    px += (forceOf(px) / GAMMA) * DT + xi * Math.sqrt(2 * KT * DT / GAMMA);
    px  = Math.max(-2.4, Math.min(2.4, px));

    // Bias deposition (illustrative enhanced sampling).
    if (mode === 'enhanced' && stepCount % BIAS_FREQ === 0) {
      var vb    = Vbias(px);
      var h_dep = BIAS_H * Math.exp(-vb / (KT * (WT_GAMMA - 1)));
      if (h_dep > 1e-4) bias.push({ c: px, h: h_dep });
    }

    traceX.push(px);
    if (traceX.length > 220) traceX.shift();

    // Update visit histogram
    var hBin = Math.floor((px - XMIN) / (XMAX - XMIN) * HIST_BINS);
    hBin = Math.max(0, Math.min(HIST_BINS - 1, hBin));
    visitHist[hBin]++;
    if (visitHist[hBin] > visitMax) visitMax = visitHist[hBin];

    stepCount++;
  }

  // ── Canvas drawing ──────────────────────────────────────────────────────────
  var H = 310;
  var W = 0;
  var dpr = 1;
  var resizeReq = 0;

  function resizeCanvas(force) {
    var nextW = canvas.offsetWidth || 600;
    var nextDpr = Math.min(window.devicePixelRatio || 1, 1.5);
    if (!force && nextW === W && nextDpr === dpr) return;
    W = nextW; dpr = nextDpr;
    canvas.width  = Math.round(W * dpr);
    canvas.height = Math.round(H * dpr);
  }

  function requestResize() {
    if (resizeReq) return;
    resizeReq = requestAnimationFrame(function () {
      resizeReq = 0;
      resizeCanvas(true);
      draw();
    });
  }

  function draw() {
    if (!W) resizeCanvas(true);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, W, H);

    var pad = { l: 60, r: 20, t: 24, b: 68 };
    var cw  = W - pad.l - pad.r;
    var ch  = H - pad.t - pad.b;

    function xc(x) { return pad.l + (x - XMIN) / (XMAX - XMIN) * cw; }
    function yc(e) { return pad.t + (1 - (e - EMIN) / (EMAX - EMIN)) * ch; }
    function clampE(e) { return Math.min(Math.max(e, EMIN), EMAX); }

    var xs = [];
    for (var i = 0; i <= NX; i++) xs.push(XMIN + (XMAX - XMIN) * i / NX);

    // ── Grid & y-axis ticks ──
    ctx.font = '9px "Space Grotesk", system-ui';
    [0, 1, 2, 3, 4].forEach(function (y) {
      if (y > EMAX) return;
      var yp = yc(y);
      ctx.strokeStyle = 'rgba(180,175,168,0.3)'; ctx.lineWidth = 0.8;
      ctx.beginPath(); ctx.moveTo(pad.l, yp); ctx.lineTo(pad.l + cw, yp); ctx.stroke();
      ctx.fillStyle = '#a0998f'; ctx.textAlign = 'right';
      ctx.fillText(y, pad.l - 5, yp + 3.5);
    });

    // Axes
    ctx.strokeStyle = '#c0bab3'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t); ctx.lineTo(pad.l, pad.t + ch);
    ctx.lineTo(pad.l + cw, pad.t + ch); ctx.stroke();

    // Y-axis label
    ctx.save();
    ctx.fillStyle = '#888'; ctx.font = '10px "Space Grotesk", system-ui';
    ctx.translate(15, pad.t + ch / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.fillText('Free energy (kcal/mol)', 0, 0);
    ctx.restore();

    // X-axis label
    ctx.fillStyle = '#888'; ctx.font = '10px "Space Grotesk", system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Conformational coordinate  \u2190 inactive to active \u2192  (illustrative)', pad.l + cw / 2, H - 7);

    // State labels
    ctx.fillStyle = '#c0b8b0'; ctx.font = '10px "Space Grotesk", system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Inactive', xc(-1.0), pad.t + 13);
    ctx.fillText('Active',   xc(+1.0), pad.t + 13);

    // ── Base landscape (gray) - identical in all modes ──
    ctx.beginPath();
    xs.forEach(function (x, i) {
      var e = clampE(Vbase(x));
      if (i === 0) ctx.moveTo(xc(x), yc(e)); else ctx.lineTo(xc(x), yc(e));
    });
    ctx.strokeStyle = '#c8c3bc'; ctx.lineWidth = 2;
    ctx.stroke();

    // ── Barrier height annotation ──
    var barrierH = Math.max(0, Vbase(0));
    if (barrierH > 0.05 && barrierH < EMAX) {
      var bx = xc(0);
      var byTop = yc(clampE(barrierH));
      var byBot = yc(0);
      // Vertical line
      ctx.strokeStyle = 'rgba(180,100,50,0.45)';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(bx + 12, byTop);
      ctx.lineTo(bx + 12, byBot);
      ctx.stroke();
      ctx.setLineDash([]);
      // Small ticks at top and bottom
      ctx.beginPath();
      ctx.moveTo(bx + 8, byTop); ctx.lineTo(bx + 16, byTop);
      ctx.moveTo(bx + 8, byBot); ctx.lineTo(bx + 16, byBot);
      ctx.stroke();
      // Label
      ctx.fillStyle = 'rgba(180,100,50,0.7)';
      ctx.font = '9px "Space Grotesk", system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(barrierH.toFixed(1) + ' kcal/mol', bx + 19, (byTop + byBot) / 2 + 3);
    }

    // ── Enhanced sampling: amber fill + effective landscape ──
    if (mode === 'enhanced' && bias.length > 3) {
      // Fill between Vbase and Vtotal
      ctx.beginPath();
      xs.forEach(function (x, i) {
        var eB = clampE(Vbase(x));
        if (i === 0) ctx.moveTo(xc(x), yc(eB)); else ctx.lineTo(xc(x), yc(eB));
      });
      for (var j = xs.length - 1; j >= 0; j--) {
        ctx.lineTo(xc(xs[j]), yc(clampE(Vtotal(xs[j]))));
      }
      ctx.closePath();
      ctx.fillStyle = 'rgba(224,139,42,0.16)';
      ctx.fill();

      // Effective surface line
      ctx.beginPath();
      xs.forEach(function (x, i) {
        var e = clampE(Vtotal(x));
        if (i === 0) ctx.moveTo(xc(x), yc(e)); else ctx.lineTo(xc(x), yc(e));
      });
      ctx.strokeStyle = 'rgba(224,139,42,0.82)'; ctx.lineWidth = 2;
      ctx.stroke();

      // Legend (appears once bias is substantial)
      if (bias.length > 40) {
        ctx.font = '9px "Space Grotesk", system-ui'; ctx.textAlign = 'left';
        ctx.fillStyle = 'rgba(200,130,50,0.75)';
        ctx.fillText('Effective surface (reference + bias)', pad.l + 4, pad.t + 10);
        ctx.fillStyle = '#c8c3bc';
        ctx.fillText('Reference surface', pad.l + 4, pad.t + 22);
      }
    }

    // ── Trajectory trail ──
    for (var ti = 1; ti < traceX.length; ti++) {
      var alpha  = (ti / traceX.length) * 0.30;
      var trailE = clampE(Vtotal(traceX[ti]));
      var prevE  = clampE(Vtotal(traceX[ti - 1]));
      ctx.strokeStyle = 'rgba(45,106,79,' + alpha + ')';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(xc(traceX[ti - 1]), yc(prevE));
      ctx.lineTo(xc(traceX[ti]),     yc(trailE));
      ctx.stroke();
    }

    // ── Particle dot ──
    var pE     = clampE(Vtotal(px));
    var pColor = (mode === 'enhanced') ? '#e08b2a' : '#6a5acd';
    ctx.beginPath();
    ctx.arc(xc(px), yc(pE), 7, 0, Math.PI * 2);
    ctx.fillStyle = pColor; ctx.fill();
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();

    // ── Visited histogram strip ──
    var histY = pad.t + ch + 8;
    var histH = 14;
    var binW  = cw / HIST_BINS;

    // Label
    ctx.fillStyle = '#a0998f';
    ctx.font = '8px "Space Grotesk", system-ui';
    ctx.textAlign = 'right';
    ctx.fillText('visited', pad.l - 5, histY + histH / 2 + 3);

    for (var hi = 0; hi < HIST_BINS; hi++) {
      var frac = visitMax > 0 ? visitHist[hi] / visitMax : 0;
      if (frac < 0.01) continue;
      var hx = pad.l + hi * binW;
      // Color: green for active side (right half), blue for inactive (left half)
      var isActive = hi >= HIST_BINS / 2;
      var alpha = 0.15 + frac * 0.55;
      ctx.fillStyle = isActive
        ? 'rgba(45,106,79,' + alpha + ')'
        : 'rgba(29,78,137,' + alpha + ')';
      ctx.fillRect(hx, histY, binW + 0.5, histH);
    }

    // Border
    ctx.strokeStyle = 'rgba(180,175,168,0.4)';
    ctx.lineWidth = 0.8;
    ctx.strokeRect(pad.l, histY, cw, histH);
  }

  // ── Animation loop ──────────────────────────────────────────────────────────
  // ── Visibility + throttled loop ─────────────────────────────────────────────
  var exchRaf = 0;
  var lastTs = 0;
  var FRAME_MS = 1000 / 30;
  var inView = false;
  var running = false;

  function setRunState() {
    var shouldRun = inView && !document.hidden;
    if (shouldRun && !running) start();
    if (!shouldRun && running) stop();
  }

  function loop(ts) {
    if (!running) return;
    if (!lastTs) lastTs = ts;
    if (ts - lastTs >= FRAME_MS) {
      lastTs = ts;
      for (var i = 0; i < STEPS_PER_FRAME; i++) step();
      draw();
    }
    exchRaf = requestAnimationFrame(loop);
  }

  function start() {
    running = true;
    lastTs = 0;
    resizeCanvas(true);
    draw();
    exchRaf = requestAnimationFrame(loop);
  }

  function stop() {
    running = false;
    if (exchRaf) cancelAnimationFrame(exchRaf);
    exchRaf = 0;
  }

  function reset() { px = -1.0; bias = []; traceX = []; stepCount = 0; visitHist = new Array(HIST_BINS).fill(0); visitMax = 1; }

  // ── Result and mode caption text ────────────────────────────────────────────
  var MODE_CAPTIONS = {
    classical: 'Standard MD: a single trajectory may stay in its starting state.',
    enhanced:  'Adaptive bias: a bias potential builds up in visited CV regions to encourage transitions (illustrative).'
  };

      function updateResultText() {
        var dg   = parseFloat(dGSlider.value);
        var dGVal = 2 * dg; // ΔG (active - inactive)
        var dGStr = dGVal.toFixed(1);

        var interpret = '';
        if (Math.abs(dg) < 0.1) {
          interpret = '\u0394G \u2248 0: similar stability in this sketch. At equilibrium, the system spends similar time in both states.';
        } else if (dg > 0) {
          interpret = '\u0394G = +' + dGStr + ' kcal/mol: the inactive state is more stable in this sketch. At equilibrium, the system spends more time in inactive conformations.';
        } else {
          interpret = '\u0394G = ' + dGStr + ' kcal/mol: the active state is more stable in this sketch. At equilibrium, the system spends more time in active conformations.';
        }

        if (mode === 'classical') {
          enhResult.textContent = 'Illustrative: with standard MD, a trajectory may remain confined to one basin and not sample the transition. ' + interpret;
        } else {
          enhResult.textContent = 'Illustrative: adaptive biasing promotes back-and-forth transitions so both states are sampled. ' + interpret;
        }

        if (modeCap) modeCap.textContent = MODE_CAPTIONS[mode];
      }

  // ── Public mode setter ──────────────────────────────────────────────────────
  window.setEnhMode = function (m) {
    mode = m;
    reset();
    ['Classical', 'Enhanced'].forEach(function (id) {
      var btn = document.getElementById('enhBtn' + id);
      if (btn) btn.classList.toggle('active', id.toLowerCase() === m.toLowerCase());
    });
    updateResultText();
  };

  // ── DG slider ───────────────────────────────────────────────────────────────
  function updateDGDisplay() {
    var dg  = parseFloat(dGSlider.value);
    DG      = dg;
    computeVMIN();   // shift potential so lower minimum stays at 0
    var ddG = (2 * dg).toFixed(1);
    dGNum.textContent = ddG;
    if (Math.abs(dg) < 0.1) {
      dGLabel.textContent = 'Symmetric';
      dGNum.style.color   = '';
    } else if (dg > 0) {
      dGLabel.textContent = 'Inactive favoured';
      dGNum.style.color   = '#b5451b';
    } else {
      dGLabel.textContent = 'Active favoured';
      dGNum.style.color   = '#2d6a4f';
    }
    reset();
    updateResultText();
  }

  dGSlider.addEventListener('input', updateDGDisplay);
  window.addEventListener('resize', requestResize);
  document.addEventListener('visibilitychange', setRunState);

  var obs = new IntersectionObserver(function (entries) {
    inView = entries.some(function (e) { return e.isIntersecting; });
    setRunState();
  }, { root: null, threshold: 0.2 });
  obs.observe(canvas);

  resizeCanvas(true);
  computeVMIN();    // initialise before first draw
  updateDGDisplay();
  setRunState();
})();
</script>

<script>
// ── Replica exchange (parallel tempering): illustrative ladder ───────────────
(function () {
  var canvas = document.getElementById('remdCanvas');
  if (!canvas) return;
  var ctx = canvas.getContext('2d');

  var toggleBtn = document.getElementById('remdToggleBtn');
  var resetBtn  = document.getElementById('remdResetBtn');

  // Display temperatures (K); dynamics use calibrated effective temperatures
  // so that the cold replica is deeply trapped and the hot one crosses freely.
  var TEMPS_K = [300, 320, 340, 360];
  var NR = TEMPS_K.length;

  // Double-well: V(s), minima at s≈0.25 (inactive) and s≈0.75 (active);
  // barrier ≈ 1 (toy units) at s = 0.5.
  function V(s) {
    var x = (s - 0.5) * 4;
    var y = (x * x - 1);
    return y * y;
  }
  function dV(s) {
    var x = (s - 0.5) * 4;
    var y = (x * x - 1);
    return 16 * x * y;
  }
  function gauss() {
    var u = Math.random() + 1e-15, v = Math.random();
    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
  }

  var W = 0, H = 340, dpr = 1, resizeReq = 0;

  function resizeCanvas(force) {
    var nextW   = canvas.offsetWidth || 600;
    var nextDpr = Math.min(window.devicePixelRatio || 1, 1.5);
    if (!force && nextW === W && nextDpr === dpr) return;
    W = nextW; dpr = nextDpr;
    canvas.width  = Math.round(W * dpr);
    canvas.height = Math.round(H * dpr);
  }
  function requestResize() {
    if (resizeReq) return;
    resizeReq = requestAnimationFrame(function () {
      resizeReq = 0; resizeCanvas(true); draw();
    });
  }

  // Effective noise levels in toy units, calibrated so:
  //   300 K (0.07): deeply trapped, no crossings
  //   360 K (1.05): freely crossing
  var TEFF = [0.07, 0.18, 0.42, 1.05];
  function Teff(i) { return TEFF[i]; }
  function beta(i) { return 1 / TEFF[i]; }

  var exchOn = false; // starts OFF
  var reps, traces, seen, swaps, tick;

  var DT = 0.007, GAMMA = 1.6;
  var STEPS_PER_FRAME = 10, TRACE_EVERY = 4;
  var SWAP_EVERY = 55, MAX_TRACE = 260, FLASH_DUR = 30;

  function reset() {
    reps = TEMPS_K.map(function (Tk, i) {
      // Cold replicas start in inactive well; hot replica starts in active.
      // makes the contrast visible immediately when exchanges are toggled.
      var s0 = (i === NR - 1) ? 0.75 : 0.25;
      return { Tk: Tk, idx: i, s: s0, vel: 0 };
    });
    traces = Array.from({ length: NR }, function (_, i) { return [reps[i].s]; });
    seen   = Array.from({ length: NR }, function (_, i) {
      return { low: reps[i].s < 0.5, high: reps[i].s >= 0.5 };
    });
    swaps = [];
    tick  = 0;
  }

  function setExch(on) {
    exchOn = !!on;
    if (!toggleBtn) return;
    toggleBtn.textContent = exchOn ? 'Exchanges ON' : 'Exchanges OFF';
    toggleBtn.classList.toggle('active', exchOn);
  }

  function stepReplica(rep) {
    var T     = Teff(rep.idx);
    var force = -dV(rep.s);
    var noise = gauss() * Math.sqrt(2 * GAMMA * T * DT);
    rep.vel   = rep.vel + (force - GAMMA * rep.vel) * DT + noise;
    rep.s     = rep.s + rep.vel * DT;
    if (rep.s < 0.04) { rep.s = 0.04; rep.vel =  Math.abs(rep.vel) * 0.25; }
    if (rep.s > 0.96) { rep.s = 0.96; rep.vel = -Math.abs(rep.vel) * 0.25; }
  }

  function attemptSwap(i) {
    var j  = i + 1;
    var ri = reps[i], rj = reps[j];
    var Ei = V(ri.s), Ej = V(rj.s);
    // Metropolis criterion. Tends to reject swaps that would make the configuration
    // very unlikely at the colder temperature.
    var logAcc = (beta(i) - beta(j)) * (Ej - Ei);
    var acc    = Math.exp(Math.min(0, logAcc));
    if (Math.random() < acc) {
      var tmp;
      tmp = ri.s;   ri.s   = rj.s;   rj.s   = tmp;
      tmp = ri.vel; ri.vel = rj.vel;  rj.vel = tmp;
      swaps.push({ i: i, j: j, age: 0 });
    }
  }

  function stepSystem() {
    tick++;
    for (var i = 0; i < NR; i++) stepReplica(reps[i]);

    if (tick % TRACE_EVERY === 0) {
      for (var r = 0; r < NR; r++) {
        traces[r].push(reps[r].s);
        if (traces[r].length > MAX_TRACE) traces[r].shift();
        if (reps[r].s < 0.5) seen[r].low  = true;
        else                  seen[r].high = true;
      }
    }

    if (exchOn && tick % SWAP_EVERY === 0) {
      var idx = Math.floor(tick / SWAP_EVERY) % (NR - 1);
      attemptSwap(idx);
    }

    swaps = swaps
      .map(function (s) { return { i: s.i, j: s.j, age: s.age + 1 }; })
      .filter(function (s) { return s.age < FLASH_DUR; });
  }

  function draw() {
    if (!W) resizeCanvas(true);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, W, H);

    var pad   = { l: 72, r: 26, t: 16, b: 20 };
    var rowH  = (H - pad.t - pad.b) / NR;
    var plotW = W - pad.l - pad.r;

    // Build per-row flash alpha from recent accepted swaps
    var rowFlash = new Array(NR).fill(0);
    swaps.forEach(function (s) {
      var a = Math.max(0, 1 - s.age / FLASH_DUR);
      rowFlash[s.i] = Math.max(rowFlash[s.i], a);
      rowFlash[s.j] = Math.max(rowFlash[s.j], a);
    });

    // ── Left axis label ──
    ctx.save();
    ctx.fillStyle = '#8b857e';
    ctx.font = '10px "Space Grotesk", system-ui';
    ctx.translate(12, pad.t + (H - pad.t - pad.b) / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.fillText('Collective variable (CV)', 0, 0);
    ctx.restore();

    // ── Per-row ──
    for (var i = 0; i < NR; i++) {
      var y0       = pad.t + i * rowH;
      var isTarget = (i === 0);

      // Base background
      ctx.fillStyle = isTarget ? 'rgba(224,139,42,0.06)' : '#f8f7f5';
      ctx.fillRect(pad.l, y0, plotW, rowH);

      // Active zone - top half (high CV) - soft green pastel
      ctx.fillStyle = 'rgba(45,140,79,0.10)';
      ctx.fillRect(pad.l, y0, plotW, rowH * 0.5);

      // Inactive zone - bottom half (low CV) - soft blue pastel
      ctx.fillStyle = 'rgba(29,78,160,0.08)';
      ctx.fillRect(pad.l, y0 + rowH * 0.5, plotW, rowH * 0.5);

      // Swap flash overlay (very subtle)
      if (rowFlash[i] > 0) {
        ctx.fillStyle = 'rgba(34,118,74,' + (rowFlash[i] * 0.06) + ')';
        ctx.fillRect(pad.l, y0, plotW, rowH);
      }

      // State labels - first row only (layout is identical for all rows)
      if (i === 0) {
        ctx.font = '8px "Space Grotesk", system-ui';
        ctx.textAlign = 'left';
        ctx.fillStyle = 'rgba(45,106,79,0.65)';
        ctx.fillText('active  \u25b2', pad.l + 5, y0 + 10);
        ctx.fillStyle = 'rgba(29,78,137,0.65)';
        ctx.fillText('inactive  \u25bc', pad.l + 5, y0 + rowH - 5);
      }

      // Midline at CV = 0.5 (the barrier)
      ctx.strokeStyle = 'rgba(200,195,188,0.9)';
      ctx.setLineDash([3, 4]);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pad.l,           y0 + rowH * 0.5);
      ctx.lineTo(pad.l + plotW,   y0 + rowH * 0.5);
      ctx.stroke();
      ctx.setLineDash([]);

      // Row separator
      if (i > 0) {
        ctx.strokeStyle = '#c8c3bc';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(pad.l - 40, y0); ctx.lineTo(pad.l + plotW + 20, y0);
        ctx.stroke();
      }

      // Temperature label (left margin)
      ctx.fillStyle = isTarget ? '#e08b2a' : '#6b6b6b';
      ctx.font = (isTarget ? '700 ' : '') + '10px "Space Grotesk", system-ui';
      ctx.textAlign = 'right';
      ctx.fillText(TEMPS_K[i] + '\u202fK' + (isTarget ? ' \u2605' : ''), pad.l - 5, y0 + rowH / 2 - 4);
      if (isTarget) {
        ctx.fillStyle = '#e08b2a';
        ctx.font = '8px "Space Grotesk", system-ui';
        ctx.fillText('target', pad.l - 5, y0 + rowH / 2 + 6);
      }

      // Trace
      var tr = traces[i];
      if (tr.length > 1) {
        ctx.beginPath();
        for (var k = 0; k < tr.length; k++) {
          var tx = pad.l + (k / (MAX_TRACE - 1)) * plotW;
          var ty = y0 + (1 - tr[k]) * rowH * 0.86 + rowH * 0.07;
          if (k === 0) ctx.moveTo(tx, ty); else ctx.lineTo(tx, ty);
        }
        ctx.strokeStyle = isTarget ? '#e08b2a' : '#8a8177';
        ctx.lineWidth   = isTarget ? 1.8 : 1.2;
        ctx.stroke();
      }

      // Current dot (pulses on swap)
      var len = tr.length;
      if (len > 0) {
        var cx = pad.l + ((len - 1) / (MAX_TRACE - 1)) * plotW;
        var cy = y0 + (1 - reps[i].s) * rowH * 0.86 + rowH * 0.07;
        var dotR = 5 + (rowFlash[i] > 0 ? rowFlash[i] * 2.5 : 0);
        ctx.beginPath();
        ctx.arc(cx, cy, dotR, 0, Math.PI * 2);
        ctx.fillStyle   = isTarget ? '#e08b2a' : '#6a5acd';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth   = 1.5;
        ctx.stroke();
      }

      // "Seen" badges: green circle = active visited, blue = inactive visited
      var bx = pad.l + plotW + 10;
      var by = y0 + rowH / 2;
      ctx.beginPath();
      ctx.arc(bx, by - 7, 5, 0, Math.PI * 2);
      ctx.fillStyle = seen[i].high ? 'rgba(45,106,79,0.85)' : 'rgba(200,195,188,0.45)';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(bx, by + 7, 5, 0, Math.PI * 2);
      ctx.fillStyle = seen[i].low ? 'rgba(29,78,137,0.85)' : 'rgba(200,195,188,0.45)';
      ctx.fill();
    }

    // "seen" column header
    ctx.fillStyle = '#a9a29a';
    ctx.font = '8px "Space Grotesk", system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('seen', pad.l + plotW + 10, pad.t + 9);

    // ── Swap arrows in the left margin ──
    swaps.forEach(function (s) {
      var a  = Math.max(0, 1 - s.age / FLASH_DUR);
      var y1 = pad.t + s.i * rowH + rowH / 2;
      var y2 = pad.t + s.j * rowH + rowH / 2;
      var ax = pad.l - 20;

      ctx.strokeStyle = 'rgba(34,118,74,' + (0.9 * a) + ')';
      ctx.lineWidth   = 2;
      ctx.beginPath();
      ctx.moveTo(ax, y1 + 9); ctx.lineTo(ax, y2 - 9);
      ctx.stroke();

      // Double-headed arrow: down toward warmer replica, up toward colder
      ctx.fillStyle = 'rgba(34,118,74,' + (0.9 * a) + ')';
      ctx.beginPath();
      ctx.moveTo(ax, y1 + 8); ctx.lineTo(ax - 5, y1 + 16); ctx.lineTo(ax + 5, y1 + 16);
      ctx.closePath(); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(ax, y2 - 8); ctx.lineTo(ax - 5, y2 - 16); ctx.lineTo(ax + 5, y2 - 16);
      ctx.closePath(); ctx.fill();

      if (a > 0.4) {
        ctx.fillStyle  = 'rgba(34,118,74,' + (0.85 * a) + ')';
        ctx.font       = '8px "Space Grotesk", system-ui';
        ctx.textAlign  = 'center';
        ctx.fillText('swap', ax, (y1 + y2) / 2 + 3);
      }
    });
  }

  // ── Visibility-throttled loop ──
  var raf = 0, lastTs = 0, FRAME_MS = 1000 / 30, inView = false, running = false;

  function setRunState() {
    var shouldRun = inView && !document.hidden;
    if (shouldRun && !running) start();
    if (!shouldRun && running) stop();
  }

  function loop(ts) {
    if (!running) return;
    if (!lastTs) lastTs = ts;
    if (ts - lastTs >= FRAME_MS) {
      lastTs = ts;
      for (var i = 0; i < STEPS_PER_FRAME; i++) stepSystem();
      draw();
    }
    raf = requestAnimationFrame(loop);
  }

  function start() { running = true; lastTs = 0; resizeCanvas(true); draw(); raf = requestAnimationFrame(loop); }
  function stop()  { running = false; if (raf) cancelAnimationFrame(raf); raf = 0; }

  reset();
  setExch(false);

  if (toggleBtn) toggleBtn.addEventListener('click', function () { setExch(!exchOn); });
  if (resetBtn)  resetBtn.addEventListener('click',  function () { reset(); draw(); });

  window.addEventListener('resize', requestResize);
  document.addEventListener('visibilitychange', setRunState);

  var obs = new IntersectionObserver(function (entries) {
    inView = entries.some(function (e) { return e.isIntersecting; });
    setRunState();
  }, { root: null, threshold: 0.2 });
  obs.observe(canvas);

  resizeCanvas(true);
  draw();
  setRunState();
})();
</script>

<script>
// ── State ─────────────────────────────────────────────────────────────────────
const TOTAL = 4;
let current = 0;
let stage   = null;

// Tuning
const TRAJ_FPS = 40; // increase to speed up trajectory playback

// Complex structures (chapters 1–4)
let comp5p7 = null;
let compWT  = null;
let structuresLoaded = false;
let activeComplex = "5p7";

// Trajectory (chapter 5)
let trajComp   = null;
let trajHandle = null;
let trajLoaded = false;
let trajPaused = false;
let pingTimer  = null;

// Colorblind mode
let cvdMode = false;

// ── Colour tokens ─────────────────────────────────────────────────────────────
// Default (standard) palette
const C_DEFAULT = {
  receptor: "#4e79a7",
  ligSame:  "#b8c9e0",
  diff5p7:  "#e08b2a",   // amber - blocker
  diffWT:   "#4daa57",   // green - activator
  body5p7:  "#f0c080",
  bodyWT:   "#a3c98c",
  dimRec:   "#6a6a6a",
  dimLig:   "#bbbbbb",
};
// Okabe-Ito colorblind-safe palette - chosen for clear visual distinction from default
const C_CVD = {
  receptor: "#009E73",   // teal green (Okabe-Ito) - strongly different from default steel blue
  ligSame:  "#a8dfd4",
  diff5p7:  "#E69F00",   // golden yellow (Okabe-Ito) - blocker; distinct from default amber
  diffWT:   "#CC79A7",   // reddish purple (Okabe-Ito) - activator
  body5p7:  "#f5e0a8",
  bodyWT:   "#e8c9dd",
  dimRec:   "#5a5a5a",
  dimLig:   "#c0c0c0",
};
// Mutable working palette - reassigned on toggle
let C = Object.assign({}, C_DEFAULT);

// ── URL helpers ───────────────────────────────────────────────────────────────
function absUrl(path) {
  return new URL(path, window.location.href).href;
}

function updateModelNote(step) {
  var el = document.getElementById("model-note");
  if (!el) return;
  if (step === 3) { el.style.display = "none"; return; }

  // Two lines for readability.
  el.innerHTML = "Models based on PDB<br>5UIW and 7O7F";
  el.style.display = "block";
}

// Camera preset: paste `nglDumpOrientation()` output here to lock the angle.
// Example: const SAVED_ORIENTATION = [ ...16 numbers... ];
const SAVED_ORIENTATION = [-99.65816124363005,-10.86076846440269,72.4069577641348,0,-71.08991766198984,-14.910092186448251,-100.08189488969956,0,17.51991527142944,-122.27921240454596,5.772322717726727,0,-55.08827146885036,-48.888480858835955,-53.69774871055902,1];

function maybeApplySavedOrientation() {
  if (!stage || !SAVED_ORIENTATION) return;
  stage.viewerControls.orient(SAVED_ORIENTATION);
}

function maybeApplySavedRotationOnly() {
  if (!stage || !SAVED_ORIENTATION) return;
  var cur = stage.viewerControls.getOrientation();
  var curArr = (cur && cur.elements) ? Array.from(cur.elements) : Array.from(cur);
  var out = curArr.slice();

  // NGL encodes zoom in the magnitude of each rotation column.
  // Copy the rotation DIRECTION from SAVED_ORIENTATION but rescale each
  // column to the current magnitude so the zoom level is not changed.
  for (var c = 0; c < 3; c++) {
    var b = c * 4;
    var savedMag = Math.sqrt(
      SAVED_ORIENTATION[b]   * SAVED_ORIENTATION[b] +
      SAVED_ORIENTATION[b+1] * SAVED_ORIENTATION[b+1] +
      SAVED_ORIENTATION[b+2] * SAVED_ORIENTATION[b+2]
    );
    var curMag = Math.sqrt(
      curArr[b]   * curArr[b] +
      curArr[b+1] * curArr[b+1] +
      curArr[b+2] * curArr[b+2]
    );
    if (savedMag < 1e-9 || curMag < 1e-9) continue;
    var s = curMag / savedMag;
    out[b]   = SAVED_ORIENTATION[b]   * s;
    out[b+1] = SAVED_ORIENTATION[b+1] * s;
    out[b+2] = SAVED_ORIENTATION[b+2] * s;
  }

  stage.viewerControls.orient(out);
  if (stage.viewer && stage.viewer.requestRender) stage.viewer.requestRender();
}

// ── CVD palette toggle ────────────────────────────────────────────────────────
function toggleCVD() {
  cvdMode = !cvdMode;
  Object.assign(C, cvdMode ? C_CVD : C_DEFAULT);
  var btn = document.getElementById("cvd-btn");
  if (btn) btn.classList.toggle("active", cvdMode);
  // Update viewer background (reduce blue tint in CVD mode)
  if (stage) stage.setParameters({ backgroundColor: cvdMode ? "#0f0f0f" : "#1a1a2a" });
  // Re-colour with new palette - no camera movement
  if (structuresLoaded || trajLoaded) recolorView(current);
}

// Lightweight colour-only update - no camera, no spin, no ping-pong restart
function recolorView(step) {
  if (!stage) return;
  if (step === 3) {
    if (trajLoaded && trajComp) {
      trajComp.setVisibility(true);
      addTrajReps(trajComp);
    }
    return;
  }
  if (!structuresLoaded) return;
  if (step === 0) {
    clearAll();
    showOnly("5p7");
    addReps(comp5p7, C.receptor, 1.0, C.body5p7, C.ligSame, C.diff5p7, 1.0);
  } else if (step === 1) {
    clearAll();
    showOnly("5p7");
    comp5p7.addRepresentation("cartoon", { sele: "15-312", color: C.dimRec, opacity: 0.18 });
    comp5p7.addRepresentation("cartoon", { sele: "314-380", color: C.dimLig, opacity: 0.25 });
    comp5p7.addRepresentation("cartoon", { sele: "314-317", color: C.ligSame, opacity: 0.7 });
    comp5p7.addRepresentation("cartoon", { sele: "318-323", color: C.diff5p7, aspectRatio: 8 });
    comp5p7.addRepresentation("licorice", {
      sele: "318-323 and not hydrogen",
      color: C.diff5p7,
      opacity: 0.9
    });
  } else if (step === 2) {
    clearAll();
    var isWT = (activeComplex === "wt");
    showOnly(isWT ? "wt" : "5p7");
    var comp = isWT ? compWT : comp5p7;
    var dc = isWT ? C.diffWT : C.diff5p7;
    var bc = isWT ? C.bodyWT : C.body5p7;
    addReps(comp, C.receptor, 1.0, bc, C.ligSame, dc, 1.0);
  }
}

// ── Trajectory play/pause ─────────────────────────────────────────────────────
function togglePlayPause() {
  var btn = document.getElementById("traj-playpause");
  if (trajPaused) {
    trajPaused = false;
    if (btn) btn.textContent = "Pause";
    if (trajHandle) startPingPong(trajHandle.trajectory, TRAJ_FPS);
  } else {
    trajPaused = true;
    stopPingPong();
    if (btn) btn.textContent = "Play";
  }
}

window.nglDumpOrientation = function() {
  if (!stage) return null;
  var m = stage.viewerControls.getOrientation();
  var arr = (m && m.elements) ? Array.from(m.elements) : Array.from(m);
  console.log("SAVED_ORIENTATION =", JSON.stringify(arr));
  return arr;
};

var rotTimer = null;

function autoViewZoom(comp, sele, duration) {
  if (rotTimer) { clearTimeout(rotTimer); rotTimer = null; }
  duration = duration || 900;
  try { comp.autoView(sele, duration); } catch (e) { comp.autoView(sele); }
  // Schedule a single rotation correction AFTER the animation completes.
  // At this point the camera is at the zoomed position with NGL's default
  // rotation. We then overlay the saved rotation while keeping the zoom.
  rotTimer = setTimeout(function() {
    rotTimer = null;
    maybeApplySavedRotationOnly();
  }, duration + 80);
}

// Optional: used by the commented-out view export tooling above.
function copyCurrentOrientation() {
  if (!stage) return;
  var m = stage.viewerControls.getOrientation();
  var arr = (m && m.elements) ? Array.from(m.elements) : Array.from(m);
  var text = JSON.stringify(arr);

  if (navigator.clipboard && window.isSecureContext) {
    navigator.clipboard.writeText(text).then(function() {
      console.log("Copied orientation to clipboard");
    }).catch(function() {
      window.prompt("Copy SAVED_ORIENTATION:", text);
    });
  } else {
    window.prompt("Copy SAVED_ORIENTATION:", text);
  }
}

// Fetch PDB text → Blob (bypasses NGL URL resolution)
function loadPDB(path, displayName) {
  return fetch(absUrl(path))
    .then(function(r) {
      if (!r.ok) throw new Error("HTTP " + r.status + " loading " + absUrl(path));
      return r.text();
    })
    .then(function(text) {
      var blob = new Blob([text], { type: "text/plain" });
      return stage.loadFile(blob, { ext: "pdb", name: displayName || path.split("/").pop() });
    });
}

function loadBinaryBlob(path, mime) {
  mime = mime || "application/octet-stream";
  var url = absUrl(path);
  return fetch(url)
    .then(function(r) {
      if (!r.ok) throw new Error("HTTP " + r.status + " loading " + url);
      return r.arrayBuffer();
    })
    .then(function(buf) {
      return new Blob([buf], { type: mime });
    });
}

function loadArrayBuffer(path) {
  var url = absUrl(path);
  return fetch(url).then(function(r) {
    if (!r.ok) throw new Error("HTTP " + r.status + " loading " + url);
    return r.arrayBuffer();
  });
}



// ── NGL init ──────────────────────────────────────────────────────────────────
function initViewer() {
  stage = new NGL.Stage("science-viewer", {
    backgroundColor: "#1a1a2a",
    antialias: true
  });
  window.addEventListener("resize", function() { stage.handleResize(); }, false);

  Promise.all([
    loadPDB("data/holo_5p7_WT_protein_only_fix.pdb", "[5P7]CCL5-CCR5"),
    loadPDB("data/holo_WT_protein_only_fix.pdb", "[6P4]CCL5-CCR5")
  ]).then(function(comps) {
    comp5p7 = comps[0];
    compWT  = comps[1];
    structuresLoaded = true;
    document.getElementById("viewer-loading").classList.add("hidden");
    // `view-tools` is commented out by default; keep this hook for later.
    applyView(0);
  }).catch(function(err) {
    var el = document.getElementById("viewer-loading");
    if (el) {
      el.textContent = String(err);
      el.style.color = "#ff9966";
      el.style.fontSize = "0.72rem";
      el.style.padding = "0.5rem";
    }
    console.error("NGL load error:", err);
  });
}

// ── Complex scene helpers ─────────────────────────────────────────────────────
function clearAll() {
  if (comp5p7) comp5p7.removeAllRepresentations();
  if (compWT)  compWT.removeAllRepresentations();
}

function showOnly(which) {
  comp5p7.setVisibility(which === "5p7");
  compWT.setVisibility(which === "wt");
}

function addReps(comp, recColor, recOpacity, bodyColor, sameColor, diffColor, diffOpacity) {
  var dOp = diffOpacity !== undefined ? diffOpacity : 1.0;
  // Receptor
  comp.addRepresentation("cartoon", {
    sele: "15-312",
    color: recColor || C.receptor,
    opacity: recOpacity !== undefined ? recOpacity : 1.0
  });
  // Chemokine. Single base cartoon covering 314-380 (ensures no ribbon gap)
  comp.addRepresentation("cartoon", {
    sele: "314-380",
    color: bodyColor || C.body5p7,
    opacity: 0.65
  });
  // Shared N-term override (positions 1-4)
  comp.addRepresentation("cartoon", {
    sele: "314-317",
    color: sameColor || C.ligSame,
    opacity: 0.9
  });
  // Variable region override (positions 5-10). Cartoon plus licorice sidechains.
  comp.addRepresentation("cartoon", {
    sele: "318-323",
    color: diffColor || C.diff5p7,
    opacity: dOp,
    aspectRatio: 7
  });
  comp.addRepresentation("licorice", {
    sele: "318-323 and not hydrogen",
    color: diffColor || C.diff5p7,
    opacity: dOp
  });
}

// ── Trajectory helpers ────────────────────────────────────────────────────────
function addTrajReps(comp) {
  comp.removeAllRepresentations();
  comp.addRepresentation("cartoon", {
    sele: "protein",
    color: C.receptor,
    opacity: 0.9
  });
  // TM6 highlight - uses diff5p7 slot so CVD toggle affects it
  comp.addRepresentation("cartoon", {
    sele: "228-264",
    color: C.diff5p7,
    opacity: 1.0,
    aspectRatio: 8
  });
}

function startPingPong(traj, fps) {
  stopPingPong();
  trajPaused = false;
  var btn = document.getElementById("traj-playpause");
  if (btn) btn.textContent = "Pause";
  fps = fps || 25;
  var n   = traj.frameCount;
  var i   = 0;
  var dir = 1;
  var dt  = Math.round(1000 / fps);

  function tick() {
    try {
      traj.setFrame(i, function() {
        // Ensure we render even if no other animation is active.
        if (stage && stage.viewer && stage.viewer.requestRender) stage.viewer.requestRender();

        i += dir;
        if (i >= n - 1) { i = n - 1; dir = -1; }
        if (i <= 0)     { i = 0;     dir =  1; }
        pingTimer = setTimeout(tick, dt);
      });
    } catch (err) {
      console.error("Trajectory playback error:", err);
      stopPingPong();
    }
  }
  tick();
}

function stopPingPong() {
  if (pingTimer) { clearTimeout(pingTimer); pingTimer = null; }
}

function initTrajScene() {
  document.getElementById("viewer-loading").classList.remove("hidden");

  // Hide complex structures while trajectory is shown
  if (comp5p7) comp5p7.setVisibility(false);
  if (compWT)  compWT.setVisibility(false);

  loadPDB("data/protein.pdb", "CCR5 trajectory").then(function(animComp) {
    trajComp = animComp;

    // Animated: receptor + TM6 highlight
    addTrajReps(trajComp);

    // Parse DCD locally and build a FramesTrajectory directly to avoid any
    // URL-based TrajectoryDatasource/MDsrv code paths (not present in some builds).
    return loadArrayBuffer("data/traj.dcd")
      .then(function(buf) {
        if (NGL && NGL.DcdParser && NGL.BinaryStreamer) {
          var streamer = new NGL.BinaryStreamer(buf);
          var parser = new NGL.DcdParser(streamer, {
            name: "traj.dcd",
            path: "data/traj.dcd"
          });
          return parser.parse();
        }
        // Fallback: let NGL try to infer a loader
        return NGL.autoLoad(new Blob([buf], { type: "application/octet-stream" }), { ext: "dcd" });
      })
      .then(function(frames) {
        var params = {
          sele: "protein",
          centerPbc: false,
          removePbc: false,
          superpose: true
        };

        if (NGL && NGL.FramesTrajectory) {
          return { trajectory: new NGL.FramesTrajectory(frames, trajComp.structure, params) };
        }

        // Fallback: StructureComponent can accept Frames in newer builds.
        return trajComp.addTrajectory(frames, params);
      });
  }).then(function(tc) {
    trajHandle = tc;
    trajLoaded = true;
    document.getElementById("viewer-loading").classList.add("hidden");
    trajComp.autoView();
    maybeApplySavedRotationOnly();
    startPingPong(tc.trajectory, TRAJ_FPS);
  }).catch(function(err) {
    var el = document.getElementById("viewer-loading");
    if (el) {
      el.textContent = String(err);
      el.style.color = "#ff9966";
      el.style.fontSize = "0.72rem";
      el.style.padding = "0.5rem";
    }
    console.error("Traj error:", err);
  });
}

// ── Per-step views ────────────────────────────────────────────────────────────
function applyView(step) {
  if (!stage) return;

  // Always stop ping-pong when changing steps
  stopPingPong();

  updateModelNote(step);

  // Prevent overlap: hide trajectory component unless we are on step 3.
  if (step !== 3 && trajComp) trajComp.setVisibility(false);

  // Traj label + play/pause controls: only on step 3
  var trajLabel = document.getElementById("traj-label");
  if (trajLabel) trajLabel.style.display = (step === 3) ? "block" : "none";
  var trajCtrl = document.getElementById("traj-controls");
  if (trajCtrl) trajCtrl.style.display = (step === 3) ? "flex" : "none";

  // Toggle buttons: only on step 2
  document.getElementById("viewer-toggle").style.display =
    (step === 2) ? "flex" : "none";

  // On step 3: hide complex structures
  if (step === 3) {
    if (comp5p7) comp5p7.setVisibility(false);
    if (compWT)  compWT.setVisibility(false);
  }

  if (!structuresLoaded && step < 3) return;

  if (step === 0) {
    clearAll();
    showOnly("5p7");
    addReps(comp5p7, C.receptor, 1.0, C.body5p7, C.ligSame, C.diff5p7, 1.0);
    comp5p7.autoView();
    stage.setSpin([0, 1, 0], 0.5);

  } else if (step === 1) {
    stage.setSpin(null);
    clearAll();
    showOnly("5p7");
    comp5p7.addRepresentation("cartoon", { sele: "15-312", color: C.dimRec, opacity: 0.18 });
    // Base: whole chemokine dimmed (continuous ribbon)
    comp5p7.addRepresentation("cartoon", { sele: "314-380", color: C.dimLig, opacity: 0.25 });
    // Shared positions override
    comp5p7.addRepresentation("cartoon", { sele: "314-317", color: C.ligSame, opacity: 0.7 });
    // Variable positions override + licorice sidechains
    comp5p7.addRepresentation("cartoon", { sele: "318-323", color: C.diff5p7, aspectRatio: 8 });
    comp5p7.addRepresentation("licorice", {
      sele: "318-323 and not hydrogen",
      color: C.diff5p7,
      opacity: 0.9
    });
    autoViewZoom(comp5p7, "314-323", 950);

  } else if (step === 2) {
    stage.setSpin(null);
    clearAll();
    var isWT = (activeComplex === "wt");
    showOnly(isWT ? "wt" : "5p7");
    var comp = isWT ? compWT : comp5p7;
    var dc = isWT ? C.diffWT : C.diff5p7;
    var bc = isWT ? C.bodyWT : C.body5p7;
    addReps(comp, C.receptor, 1.0, bc, C.ligSame, dc, 1.0);
    autoViewZoom(comp, "318-323", 950);

  } else if (step === 3) {
    stage.setSpin(null);
    if (!trajLoaded) {
      initTrajScene();
    } else {
      // Re-show traj component and restart ping-pong
      if (trajComp) { trajComp.setVisibility(true); addTrajReps(trajComp); }
      trajComp.autoView();
      maybeApplySavedRotationOnly();
      startPingPong(trajHandle.trajectory, TRAJ_FPS);
    }
  }

  // Steps 1 and 2 use autoViewZoom which schedules rotation via timer.
  // calling it here (before animation starts) would copy the wrong zoom level.
  if (step !== 1 && step !== 2) {
    maybeApplySavedRotationOnly();
  }
}

// ── Toggle (chapter 3) ────────────────────────────────────────────────────────
function switchComplex(which) {
  activeComplex = which;
  document.getElementById("toggle-5p7").classList.toggle("active", which === "5p7");
  document.getElementById("toggle-wt").classList.toggle("active",  which === "wt");
  updateModelNote(current);
  if (current === 2) applyView(2);
}

// ── Navigation ────────────────────────────────────────────────────────────────
function goToStep(n) {
  if (n < 0 || n >= TOTAL) return;

  document.getElementById("chapter-" + current).classList.remove("active");
  var dots = document.querySelectorAll(".step-dot");
  dots[current].classList.remove("active");
  dots[current].setAttribute("aria-selected", "false");

  current = n;

  document.getElementById("chapter-" + current).classList.add("active");
  dots[current].classList.add("active");
  dots[current].setAttribute("aria-selected", "true");
  document.getElementById("step-counter").textContent = (current + 1) + " / " + TOTAL;

  document.getElementById("btn-prev").disabled = (current === 0);
  var btnNext = document.getElementById("btn-next");
  if (current === TOTAL - 1) {
    btnNext.textContent = "← Back to Home";
    btnNext.onclick = function() { window.location.href = "index.html"; };
  } else {
    btnNext.textContent = "Next →";
    btnNext.onclick = function() { stepNav(1); };
  }

  applyView(current);
}

function stepNav(dir) { goToStep(current + dir); }

// ── Boot ──────────────────────────────────────────────────────────────────────
window.addEventListener("load", function() {
  if (typeof NGL !== "undefined") {
    initViewer();
  } else {
    var el = document.getElementById("viewer-loading");
    if (el) {
      el.textContent = "3D viewer unavailable. NGL failed to load.";
      el.style.color = "#ff9966";
    }
  }
});
</script>



</main> <!-- /main -->
<footer class="research-footer">Interactive content on this site illustrates methods used in my ongoing research. Unless explicitly cited as public reference data (e.g., PDB IDs), numbers, curves, and simulated examples are illustrative and do not represent results from any specific study. Results will be reported in future publications.</footer>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>